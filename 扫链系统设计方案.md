# TimeLocker 扫链系统设计方案

## 项目架构分析

### 现有架构
- **架构模式**: 三层架构 (Handler -> Service -> Repository)
- **数据库**: PostgreSQL + GORM，完善的迁移系统
- **配置管理**: Viper + config.yaml
- **链支持**: 支持17条主网 + 3条测试网，具备完整的RPC配置
- **Timelock标准**: Compound 和 OpenZeppelin 两种标准

### 技术栈
- **语言**: Go 1.23.10
- **数据库**: PostgreSQL + GORM + Redis
- **区块链交互**: go-ethereum
- **配置**: Viper
- **日志**: 自定义logger包

### 具体的流程和功能描述

```
首先检查rpc是否ok，当主要的rpc不行的时候，遵循alchemy、infura、official_rpc_urls（support_chains中有记录，api是在config.yaml中）；
随后连接rpc，进行扫链（support_chains中所有的链，一个链一个协程），还需要有一个表记录各个链当前扫到哪个块了（定时查找，不要超过rpc的速率，到达最新的块之后，可以调整更慢的速率），从创世块开始扫（也就是第一次运行时，初始为0，后面运行时根据表中的数据来），这个表更新频率不要太高，但要确保它所记录的区块号之前的所有区块已经确定扫描过了（很重要，不能遗漏需要记录的事件）；
将所有timelock相关的交易全部记录下来，然后分别记录在各自的表中（compound_timelock_transactions和openzeppelin_timelock_transactions），需要记录包含但不限于以下信息（该交易的hash、from、to、区块号、交易时间、合约地址、event中的信息）；
最重要的是需要将一个timelock合约发出的完整流程关联起来，比如哪次是提案的，哪次是执行的，等等等，因为要让前端显示的表达出来；
还需要有一个功能，从某个区块后重新扫描链，按照那次交易的区块号往后扫描（先停止那个链的扫描，更改表中区块号，然后重新扫描）；
也就是说我们后端是扫描链上所有的与timelock相关的事件，并且存下来，别忘了我们这是一个管理系统，其中是有用户的，前端要获取交易并显示时，我们后端只知道钱包地址和链id，我们需要根据compound_timelocks表和openzeppelin_timelocks表获取与该用户相关的合约（只要该地址是该合约的创建者、导入者、提案者、执行者、取消者等，就是相关的），然后再在相关的表中（需要设计的表）查询所有相关的交易，给前端去显示；
还有重写timelock合约的增删改查部分（重新设计表），为了防篡改等安全问题，前端只传给我们后端这些数据（用户地址、合约标准、合约地址、链id、备注），我们需要后端自己从链上去获取各种信息（比如Compound标准的GRACE_PERIOD、MINIMUM_DELAY、MAXIMUM_DELAY、admin、pendingAdmin、delay或者OpenZeppelin标准的_minDelay、proposers、executors、admin等信息）；
最后，我还需要实现一个邮件推送系统，当监听到用户所创建的合约交易的状态发生变化时（比如提案了个什么，从等待到能执行了等等），就会向用户指定到邮箱发送邮件通知，该系统暂时不要设计，后面再设计，但记住有这一模块，需要适配前面所设计的；
重要的配置在config.yaml中配置，代码中读取就行；
```

## 扫链系统总体设计

### 1. 系统架构设计

```
┌─────────────────────────────────────────────────────────────────┐
│                        扫链系统架构                               │
├─────────────────────────────────────────────────────────────────┤
│  Chain Scanner Manager                                          │
│  ├── RPC Health Monitor     (RPC健康检查)                       │
│  ├── Chain Scanner Pool     (扫链协程池)                        │
│  ├── Block Progress Tracker (区块进度管理)                      │
│  └── Event Processor        (事件处理器)                        │
├─────────────────────────────────────────────────────────────────┤
│  Data Layer                                                     │
│  ├── Block Scan Progress    (扫描进度表)                        │
│  ├── Timelock Transactions (交易记录表)                         │
│  ├── Transaction Relations  (交易关联表)                        │
│  └── Contract Management    (合约管理增强)                       │
├─────────────────────────────────────────────────────────────────┤
│  Notification System (预留)                                     │
│  └── Email Notification     (邮件通知模块)                      │
└─────────────────────────────────────────────────────────────────┘
```

### 2. 模块设计详情

## 模块一：RPC 健康检查与管理

### 2.1 RPC 管理器设计

**文件结构:**
```
internal/
  service/
    scanner/
      rpc_manager.go         # RPC管理器
      health_checker.go      # 健康检查器
  types/
    scanner.go              # 扫链相关类型定义
```

**核心功能:**
1. **RPC优先级管理**: Alchemy -> Infura -> Official RPC URLs
2. **健康检查机制**: 每30秒检查一次RPC可用性
3. **自动切换机制**: 主RPC失败时自动切换到备用RPC
4. **错误重试策略**: 指数退避重试，最大重试3次
5. **RPC性能监控**: 记录响应时间和成功率

**配置扩展(config.yaml):**
```yaml
scanner:
  # RPC健康检查配置
  rpc_health_check_interval: "30s"    # RPC健康检查间隔
  rpc_timeout: "10s"                  # RPC请求超时时间
  rpc_retry_max: 3                    # RPC最大重试次数
  rpc_retry_delay: "1s"               # RPC重试延迟
  
  # 扫块配置
  scan_batch_size: 100                # 每批扫描的区块数量
  scan_interval: "5s"                 # 快速扫描间隔
  scan_interval_slow: "30s"           # 慢速扫描间隔（到达最新块后）
  scan_confirmations: 12              # 区块确认数
  max_scan_workers: 20                # 最大扫描协程数
  
  # 事件处理配置
  event_batch_size: 50                # 每批处理的事件数量
  event_retry_max: 3                  # 事件处理最大重试次数
```

## 模块二：区块扫描进度管理

### 2.2 数据库表设计

**新增表结构:**

```sql
-- 1. 区块扫描进度表
CREATE TABLE block_scan_progress (
    id BIGSERIAL PRIMARY KEY,
    chain_id INTEGER NOT NULL UNIQUE,                    -- 链ID
    chain_name VARCHAR(50) NOT NULL,                    -- 链名称
    last_scanned_block BIGINT NOT NULL DEFAULT 0,       -- 最后扫描的区块号
    latest_network_block BIGINT DEFAULT 0,              -- 网络最新区块号
    scan_status VARCHAR(20) NOT NULL DEFAULT 'running', -- 扫描状态: running, paused, error
    error_message TEXT,                                 -- 错误信息
    last_update_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 2. Compound Timelock 交易记录表
CREATE TABLE compound_timelock_transactions (
    id BIGSERIAL PRIMARY KEY,
    tx_hash VARCHAR(66) NOT NULL,                       -- 交易哈希
    block_number BIGINT NOT NULL,                       -- 区块号
    block_timestamp TIMESTAMP WITH TIME ZONE NOT NULL,  -- 区块时间戳
    chain_id INTEGER NOT NULL,                          -- 链ID
    chain_name VARCHAR(50) NOT NULL,                    -- 链名称
    contract_address VARCHAR(42) NOT NULL,              -- 合约地址
    from_address VARCHAR(42) NOT NULL,                  -- 发起人地址
    to_address VARCHAR(42) NOT NULL,                    -- 目标地址
    
    -- 事件类型和数据
    event_type VARCHAR(50) NOT NULL,                    -- 事件类型: QueueTransaction, ExecuteTransaction, CancelTransaction, NewDelay, NewAdmin, NewPendingAdmin
    event_data JSONB NOT NULL,                          -- 事件详细数据
    
    -- 关联信息
    proposal_id VARCHAR(128),                           -- 提案ID (从事件计算得出)
    target_address VARCHAR(42),                         -- 目标合约地址
    function_signature VARCHAR(200),                    -- 函数签名
    call_data BYTEA,                                   -- 调用数据
    eta BIGINT,                                        -- 执行时间戳
    value DECIMAL(36,0) DEFAULT 0,                     -- 转账金额
    
    -- 索引字段
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    UNIQUE(tx_hash, contract_address, event_type)
);

-- 3. OpenZeppelin Timelock 交易记录表
CREATE TABLE openzeppelin_timelock_transactions (
    id BIGSERIAL PRIMARY KEY,
    tx_hash VARCHAR(66) NOT NULL,                       -- 交易哈希
    block_number BIGINT NOT NULL,                       -- 区块号
    block_timestamp TIMESTAMP WITH TIME ZONE NOT NULL,  -- 区块时间戳
    chain_id INTEGER NOT NULL,                          -- 链ID
    chain_name VARCHAR(50) NOT NULL,                    -- 链名称
    contract_address VARCHAR(42) NOT NULL,              -- 合约地址
    from_address VARCHAR(42) NOT NULL,                  -- 发起人地址
    to_address VARCHAR(42) NOT NULL,                    -- 目标地址
    
    -- 事件类型和数据
    event_type VARCHAR(50) NOT NULL,                    -- 事件类型: CallScheduled, CallExecuted, Cancelled, MinDelayChange, RoleGranted, RoleRevoked
    event_data JSONB NOT NULL,                          -- 事件详细数据
    
    -- 关联信息
    operation_id VARCHAR(66),                           -- 操作ID (bytes32)
    target_address VARCHAR(42),                         -- 目标合约地址
    function_signature VARCHAR(200),                    -- 函数签名
    call_data BYTEA,                                   -- 调用数据
    delay BIGINT,                                      -- 延迟时间
    value DECIMAL(36,0) DEFAULT 0,                     -- 转账金额
    
    -- 索引字段
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    UNIQUE(tx_hash, contract_address, event_type)
);

-- 4. Timelock 交易流程关联表
CREATE TABLE timelock_transaction_flows (
    id BIGSERIAL PRIMARY KEY,
    flow_id VARCHAR(128) NOT NULL,                      -- 流程ID (提案ID或操作ID)
    timelock_standard VARCHAR(20) NOT NULL,             -- timelock 标准: compound, openzeppelin
    chain_id INTEGER NOT NULL,                          -- 链ID
    contract_address VARCHAR(42) NOT NULL,              -- 合约地址
    
    -- 流程状态
    status VARCHAR(20) NOT NULL DEFAULT 'proposed',     -- 状态: proposed, queued, executed, cancelled, expired
    
    -- 关键交易ID
    propose_tx_id BIGINT,                               -- 提案交易ID
    queue_tx_id BIGINT,                                 -- 队列交易ID (仅Compound)
    execute_tx_id BIGINT,                               -- 执行交易ID
    cancel_tx_id BIGINT,                                -- 取消交易ID
    
    -- 时间信息
    proposed_at TIMESTAMP WITH TIME ZONE,               -- 提案时间
    queued_at TIMESTAMP WITH TIME ZONE,                 -- 队列时间
    executed_at TIMESTAMP WITH TIME ZONE,               -- 执行时间
    cancelled_at TIMESTAMP WITH TIME ZONE,              -- 取消时间
    eta TIMESTAMP WITH TIME ZONE,                       -- 可执行时间
    
    -- 提案详情
    target_address VARCHAR(42),                         -- 目标合约
    function_signature VARCHAR(200),                    -- 函数签名
    call_data BYTEA,                                   -- 调用数据
    value DECIMAL(36,0) DEFAULT 0,                     -- 转账金额
    description TEXT,                                   -- 描述
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    UNIQUE(flow_id, timelock_standard, chain_id, contract_address)
);

-- 5. 用户-合约关联表 (增强版)
CREATE TABLE user_timelock_relations (
    id BIGSERIAL PRIMARY KEY,
    user_address VARCHAR(42) NOT NULL,                  -- 用户地址
    chain_id INTEGER NOT NULL,                          -- 链ID
    contract_address VARCHAR(42) NOT NULL,              -- 合约地址
    timelock_standard VARCHAR(20) NOT NULL,             -- timelock 标准
    
    -- 关联类型
    relation_type VARCHAR(20) NOT NULL,                 -- 关联类型: creator, admin, pending_admin, proposer, executor, canceller
    
    -- 关联时间和状态
    related_at TIMESTAMP WITH TIME ZONE NOT NULL,       -- 关联建立时间
    is_active BOOLEAN NOT NULL DEFAULT true,            -- 是否活跃
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    UNIQUE(user_address, chain_id, contract_address, relation_type)
);
```

### 2.3 索引设计

```sql
-- 区块扫描进度表索引
CREATE INDEX IF NOT EXISTS idx_block_scan_progress_chain_id ON block_scan_progress(chain_id);
CREATE INDEX IF NOT EXISTS idx_block_scan_progress_status ON block_scan_progress(scan_status);

-- Compound交易表索引
CREATE INDEX IF NOT EXISTS idx_compound_timelock_transactions_block_number ON compound_timelock_transactions(block_number);
CREATE INDEX IF NOT EXISTS idx_compound_timelock_transactions_contract_address ON compound_timelock_transactions(contract_address);
CREATE INDEX IF NOT EXISTS idx_compound_timelock_transactions_from_address ON compound_timelock_transactions(from_address);
CREATE INDEX IF NOT EXISTS idx_compound_timelock_transactions_event_type ON compound_timelock_transactions(event_type);
CREATE INDEX IF NOT EXISTS idx_compound_timelock_transactions_proposal_id ON compound_timelock_transactions(proposal_id);
CREATE INDEX IF NOT EXISTS idx_compound_timelock_transactions_chain_block ON compound_timelock_transactions(chain_id, block_number);

-- OpenZeppelin交易表索引
CREATE INDEX IF NOT EXISTS idx_openzeppelin_timelock_transactions_block_number ON openzeppelin_timelock_transactions(block_number);
CREATE INDEX IF NOT EXISTS idx_openzeppelin_timelock_transactions_contract_address ON openzeppelin_timelock_transactions(contract_address);
CREATE INDEX IF NOT EXISTS idx_openzeppelin_timelock_transactions_from_address ON openzeppelin_timelock_transactions(from_address);
CREATE INDEX IF NOT EXISTS idx_openzeppelin_timelock_transactions_event_type ON openzeppelin_timelock_transactions(event_type);
CREATE INDEX IF NOT EXISTS idx_openzeppelin_timelock_transactions_operation_id ON openzeppelin_timelock_transactions(operation_id);
CREATE INDEX IF NOT EXISTS idx_openzeppelin_timelock_transactions_chain_block ON openzeppelin_timelock_transactions(chain_id, block_number);

-- 交易流程关联表索引
CREATE INDEX IF NOT EXISTS idx_timelock_transaction_flows_flow_id ON timelock_transaction_flows(flow_id);
CREATE INDEX IF NOT EXISTS idx_timelock_transaction_flows_contract_address ON timelock_transaction_flows(contract_address);
CREATE INDEX IF NOT EXISTS idx_timelock_transaction_flows_status ON timelock_transaction_flows(status);
CREATE INDEX IF NOT EXISTS idx_timelock_transaction_flows_chain_contract ON timelock_transaction_flows(chain_id, contract_address);

-- 用户关联表索引
CREATE INDEX IF NOT EXISTS idx_user_timelock_relations_user_address ON user_timelock_relations(user_address);
CREATE INDEX IF NOT EXISTS idx_user_timelock_relations_contract_address ON user_timelock_relations(contract_address);
CREATE INDEX IF NOT EXISTS idx_user_timelock_relations_relation_type ON user_timelock_relations(relation_type);
CREATE INDEX IF NOT EXISTS idx_user_timelock_relations_is_active ON user_timelock_relations(is_active);
CREATE INDEX IF NOT EXISTS idx_user_timelock_relations_user_chain ON user_timelock_relations(user_address, chain_id);
```

## 模块三：扫链核心引擎

### 3.1 扫链管理器设计

**核心组件:**

1. **ScannerManager**: 扫链管理器主控制器
2. **ChainScanner**: 单链扫描器
3. **BlockProcessor**: 区块处理器
4. **EventProcessor**: 事件处理器
5. **TransactionBuilder**: 交易记录构建器

**文件结构:**
```
internal/
  service/
    scanner/
      manager.go              # 扫链管理器
      chain_scanner.go        # 单链扫描器
      block_processor.go      # 区块处理器
      event_processor.go      # 事件处理器
      transaction_builder.go  # 交易构建器
      contract_detector.go    # 合约检测器
  repository/
    scanner/
      progress_repository.go  # 进度管理仓库
      transaction_repository.go # 交易记录仓库
      flow_repository.go      # 流程管理仓库
```

### 3.2 扫链逻辑设计

**扫描流程:**
1. **初始化阶段**: 加载所有启用RPC的链配置
2. **启动阶段**: 为每条链启动一个独立的扫描协程
3. **扫描阶段**: 
   - 获取当前扫描进度
   - 批量获取区块数据
   - 解析timelock相关事件
   - 构建交易记录和关联关系
   - 更新扫描进度
4. **监控阶段**: 监控扫描状态，处理异常情况

**速率控制策略:**
- **快速扫描**: 落后超过100个区块时，5秒间隔扫描
- **慢速扫描**: 接近最新区块时，30秒间隔扫描
- **智能调整**: 根据网络状况和RPC限制动态调整

## 模块四：事件识别与解析

### 4.1 Compound Timelock 事件解析

**监听事件:**
1. **QueueTransaction**: 交易进入队列
2. **ExecuteTransaction**: 交易执行
3. **CancelTransaction**: 交易取消
4. **NewDelay**: 延迟时间变更
5. **NewAdmin**: 管理员变更
6. **NewPendingAdmin**: 待定管理员设置

**事件数据结构:**
```go
type CompoundTimelockEvent struct {
    EventType        string                 `json:"event_type"`
    TxHash          string                 `json:"tx_hash"`
    BlockNumber     uint64                 `json:"block_number"`
    ContractAddress string                 `json:"contract_address"`
    
    // QueueTransaction / ExecuteTransaction / CancelTransaction
    Target          *string                `json:"target,omitempty"`
    Value           *string                `json:"value,omitempty"`
    Signature       *string                `json:"signature,omitempty"`
    Data            *string                `json:"data,omitempty"`
    Eta             *uint64                `json:"eta,omitempty"`
    
    // NewDelay
    NewDelay        *uint64                `json:"new_delay,omitempty"`
    
    // NewAdmin / NewPendingAdmin
    NewAdmin        *string                `json:"new_admin,omitempty"`
    OldAdmin        *string                `json:"old_admin,omitempty"`
}
```

### 4.2 OpenZeppelin Timelock 事件解析

**监听事件:**
1. **CallScheduled**: 调用被安排
2. **CallExecuted**: 调用被执行  
3. **Cancelled**: 调用被取消
4. **MinDelayChange**: 最小延迟变更
5. **RoleGranted**: 角色授予
6. **RoleRevoked**: 角色撤销

**事件数据结构:**
```go
type OpenZeppelinTimelockEvent struct {
    EventType        string                 `json:"event_type"`
    TxHash          string                 `json:"tx_hash"`
    BlockNumber     uint64                 `json:"block_number"`
    ContractAddress string                 `json:"contract_address"`
    
    // CallScheduled / CallExecuted / Cancelled
    OperationId     *string                `json:"operation_id,omitempty"`
    Index           *uint64                `json:"index,omitempty"`
    Target          *string                `json:"target,omitempty"`
    Value           *string                `json:"value,omitempty"`
    Data            *string                `json:"data,omitempty"`
    Predecessor     *string                `json:"predecessor,omitempty"`
    Delay           *uint64                `json:"delay,omitempty"`
    
    // MinDelayChange
    OldDuration     *uint64                `json:"old_duration,omitempty"`
    NewDuration     *uint64                `json:"new_duration,omitempty"`
    
    // RoleGranted / RoleRevoked
    Role            *string                `json:"role,omitempty"`
    Account         *string                `json:"account,omitempty"`
    Sender          *string                `json:"sender,omitempty"`
}
```

## 模块五：交易流程关联系统

### 5.1 流程识别逻辑

**Compound Timelock 流程:**
1. **QueueTransaction** → **ExecuteTransaction** (成功执行)
2. **QueueTransaction** → **CancelTransaction** (被取消)
3. 通过 `target + value + signature + data + eta` 组合生成唯一的流程ID

**OpenZeppelin Timelock 流程:**
1. **CallScheduled** → **CallExecuted** (成功执行)
2. **CallScheduled** → **Cancelled** (被取消)
3. 通过 `operation_id` 直接关联

### 5.2 状态管理

**流程状态定义:**
- **proposed**: 已提案 (CallScheduled)
- **queued**: 已进入队列 (QueueTransaction) 
- **executed**: 已执行 (ExecuteTransaction/CallExecuted)
- **cancelled**: 已取消 (CancelTransaction/Cancelled)
- **expired**: 已过期 (超过执行窗口期)

## 模块六：合约管理系统重构

### 6.1 重构背景和目标

**重构原因:**
根据文档流程描述，为了防篡改等安全问题，前端只传给后端基本数据（用户地址、合约标准、合约地址、链id、备注），后端需要自己从链上获取各种详细信息并存储到数据库中。

**设计目标:**
- **前端简化**: 只传入用户地址、合约标准、合约地址、链ID、备注
- **后端增强**: 从链上获取合约关键信息并存储
- **安全保障**: 防止前端篡改合约关键信息
- **用户关联**: 支持根据合约表查询用户相关的合约（创建者、管理员、提案者、执行者等）

### 6.2 重构后的数据库表设计

#### 6.2.1 Compound Timelock 合约表

```sql
-- Compound Timelock 合约表 (重构版)
CREATE TABLE compound_timelocks (
    id BIGSERIAL PRIMARY KEY,
    
    -- 基本信息 (前端传入)
    creator_address VARCHAR(42) NOT NULL REFERENCES users(wallet_address) ON DELETE CASCADE,
    chain_id INTEGER NOT NULL,
    chain_name VARCHAR(50) NOT NULL, -- 从 support_chains 表获取
    contract_address VARCHAR(42) NOT NULL,
    remark VARCHAR(500) DEFAULT '',
    
    -- 管理字段
    status VARCHAR(20) NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'inactive', 'deleted')),
    is_imported BOOLEAN NOT NULL DEFAULT false, -- true=导入现有合约, false=创建新合约
    
    -- 从链上获取的 Compound Timelock 详细信息
    grace_period BIGINT, -- 宽限期(秒) - GRACE_PERIOD
    minimum_delay BIGINT, -- 最小延迟(秒) - MINIMUM_DELAY  
    maximum_delay BIGINT, -- 最大延迟(秒) - MAXIMUM_DELAY
    delay BIGINT, -- 当前延迟(秒) - delay()
    admin VARCHAR(42), -- 当前管理员 - admin()
    pending_admin VARCHAR(42), -- 待定管理员 - pendingAdmin()
    
    -- 同步状态管理
    last_sync_at TIMESTAMP WITH TIME ZONE, -- 最后同步时间
    sync_status VARCHAR(20) DEFAULT 'pending' CHECK (sync_status IN ('pending', 'synced', 'failed')),
    sync_error TEXT, -- 同步错误信息
    
    -- 时间戳
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    UNIQUE(chain_id, contract_address)
);
```

#### 6.2.2 OpenZeppelin Timelock 合约表

```sql
-- OpenZeppelin Timelock 合约表 (重构版)
CREATE TABLE openzeppelin_timelocks (
    id BIGSERIAL PRIMARY KEY,
    
    -- 基本信息 (前端传入)
    creator_address VARCHAR(42) NOT NULL REFERENCES users(wallet_address) ON DELETE CASCADE,
    chain_id INTEGER NOT NULL,
    chain_name VARCHAR(50) NOT NULL, -- 从 support_chains 表获取
    contract_address VARCHAR(42) NOT NULL,
    remark VARCHAR(500) DEFAULT '',
    
    -- 管理字段
    status VARCHAR(20) NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'inactive', 'deleted')),
    is_imported BOOLEAN NOT NULL DEFAULT false, -- true=导入现有合约, false=创建新合约
    
    -- 从链上获取的 OpenZeppelin Timelock 详细信息
    min_delay BIGINT, -- 最小延迟(秒) - getMinDelay()
    admin VARCHAR(42), -- 管理员 - 通过角色查询获取
    
    -- 角色成员列表 (从链上获取)
    proposers TEXT[], -- 提议者列表 - PROPOSER_ROLE members
    executors TEXT[], -- 执行者列表 - EXECUTOR_ROLE members
    
    -- 同步状态管理
    last_sync_at TIMESTAMP WITH TIME ZONE, -- 最后同步时间
    sync_status VARCHAR(20) DEFAULT 'pending' CHECK (sync_status IN ('pending', 'synced', 'failed')),
    sync_error TEXT, -- 同步错误信息
    
    -- 时间戳
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    UNIQUE(chain_id, contract_address)
);
```

### 6.3 索引设计

```sql
-- Compound Timelock 表索引
CREATE INDEX IF NOT EXISTS idx_compound_timelocks_creator_address ON compound_timelocks(creator_address);
CREATE INDEX IF NOT EXISTS idx_compound_timelocks_chain_id ON compound_timelocks(chain_id);
CREATE INDEX IF NOT EXISTS idx_compound_timelocks_contract_address ON compound_timelocks(contract_address);
CREATE INDEX IF NOT EXISTS idx_compound_timelocks_status ON compound_timelocks(status);
CREATE INDEX IF NOT EXISTS idx_compound_timelocks_admin ON compound_timelocks(admin);
CREATE INDEX IF NOT EXISTS idx_compound_timelocks_pending_admin ON compound_timelocks(pending_admin);
CREATE INDEX IF NOT EXISTS idx_compound_timelocks_sync_status ON compound_timelocks(sync_status);

-- Compound 复合索引
CREATE INDEX IF NOT EXISTS idx_compound_timelocks_creator_chain ON compound_timelocks(creator_address, chain_id);
CREATE INDEX IF NOT EXISTS idx_compound_timelocks_chain_status ON compound_timelocks(chain_id, status);

-- OpenZeppelin Timelock 表索引
CREATE INDEX IF NOT EXISTS idx_openzeppelin_timelocks_creator_address ON openzeppelin_timelocks(creator_address);
CREATE INDEX IF NOT EXISTS idx_openzeppelin_timelocks_chain_id ON openzeppelin_timelocks(chain_id);
CREATE INDEX IF NOT EXISTS idx_openzeppelin_timelocks_contract_address ON openzeppelin_timelocks(contract_address);
CREATE INDEX IF NOT EXISTS idx_openzeppelin_timelocks_status ON openzeppelin_timelocks(status);
CREATE INDEX IF NOT EXISTS idx_openzeppelin_timelocks_admin ON openzeppelin_timelocks(admin);
CREATE INDEX IF NOT EXISTS idx_openzeppelin_timelocks_sync_status ON openzeppelin_timelocks(sync_status);

-- OpenZeppelin 复合索引
CREATE INDEX IF NOT EXISTS idx_openzeppelin_timelocks_creator_chain ON openzeppelin_timelocks(creator_address, chain_id);
CREATE INDEX IF NOT EXISTS idx_openzeppelin_timelocks_chain_status ON openzeppelin_timelocks(chain_id, status);

-- 角色成员数组索引 (支持用户关联查询)
CREATE INDEX IF NOT EXISTS idx_openzeppelin_timelocks_proposers ON openzeppelin_timelocks USING GIN (proposers);
CREATE INDEX IF NOT EXISTS idx_openzeppelin_timelocks_executors ON openzeppelin_timelocks USING GIN (executors);
```

### 6.4 API 接口设计

#### 6.4.1 导入/创建合约请求

```go
// 导入合约请求 (前端只需要提供基本信息)
type ImportTimelockContractRequest struct {
    UserAddress     string `json:"user_address" binding:"required,eth_addr"`
    Standard        string `json:"standard" binding:"required,oneof=compound openzeppelin"`
    ContractAddress string `json:"contract_address" binding:"required,eth_addr"`
    ChainID         int    `json:"chain_id" binding:"required,min=1"`
    Remark          string `json:"remark" binding:"max=500"`
    IsImported      bool   `json:"is_imported"` // true=导入现有合约, false=创建新合约
}

// 合约同步响应
type ContractSyncResponse struct {
    ContractID    int64      `json:"contract_id"`
    SyncStatus    string     `json:"sync_status"`
    SyncError     string     `json:"sync_error,omitempty"`
    SyncedAt      *time.Time `json:"synced_at,omitempty"`
}
```

#### 6.4.2 合约信息结构

```go
// Compound Timelock 合约信息
type CompoundTimelockInfo struct {
    ID              int64     `json:"id"`
    CreatorAddress  string    `json:"creator_address"`
    ChainID         int       `json:"chain_id"`
    ChainName       string    `json:"chain_name"`
    ContractAddress string    `json:"contract_address"`
    Remark          string    `json:"remark"`
    Status          string    `json:"status"`
    IsImported      bool      `json:"is_imported"`
    
    // 从链上获取的详细信息
    GracePeriod     *int64    `json:"grace_period,omitempty"`
    MinimumDelay    *int64    `json:"minimum_delay,omitempty"`
    MaximumDelay    *int64    `json:"maximum_delay,omitempty"`
    Delay           *int64    `json:"delay,omitempty"`
    Admin           *string   `json:"admin,omitempty"`
    PendingAdmin    *string   `json:"pending_admin,omitempty"`
    
    // 同步状态
    LastSyncAt      *time.Time `json:"last_sync_at,omitempty"`
    SyncStatus      string     `json:"sync_status"`
    SyncError       *string    `json:"sync_error,omitempty"`
    
    CreatedAt       time.Time  `json:"created_at"`
    UpdatedAt       time.Time  `json:"updated_at"`
}

// OpenZeppelin Timelock 合约信息
type OpenZeppelinTimelockInfo struct {
    ID              int64     `json:"id"`
    CreatorAddress  string    `json:"creator_address"`
    ChainID         int       `json:"chain_id"`
    ChainName       string    `json:"chain_name"`
    ContractAddress string    `json:"contract_address"`
    Remark          string    `json:"remark"`
    Status          string    `json:"status"`
    IsImported      bool      `json:"is_imported"`
    
    // 从链上获取的详细信息
    MinDelay        *int64    `json:"min_delay,omitempty"`
    Admin           *string   `json:"admin,omitempty"`
    Proposers       []string  `json:"proposers,omitempty"`
    Executors       []string  `json:"executors,omitempty"`
    
    // 同步状态
    LastSyncAt      *time.Time `json:"last_sync_at,omitempty"`
    SyncStatus      string     `json:"sync_status"`
    SyncError       *string    `json:"sync_error,omitempty"`
    
    CreatedAt       time.Time  `json:"created_at"`
    UpdatedAt       time.Time  `json:"updated_at"`
}
```

### 6.5 用户关联合约查询

#### 6.5.1 用户关联查询逻辑

**Compound Timelock 用户关联查询:**
```sql
-- 查找用户相关的 Compound Timelock 合约
SELECT 
    ct.*,
    CASE 
        WHEN ct.creator_address = $1 THEN 'creator'
        WHEN ct.admin = $1 THEN 'admin'  
        WHEN ct.pending_admin = $1 THEN 'pending_admin'
        ELSE 'related'
    END as user_relation
FROM compound_timelocks ct
WHERE ct.status = 'active'
  AND (
    ct.creator_address = $1 OR  -- 创建者
    ct.admin = $1 OR           -- 当前管理员
    ct.pending_admin = $1      -- 待定管理员
  )
  AND ($2::int IS NULL OR ct.chain_id = $2); -- 可选的链ID过滤
```

**OpenZeppelin Timelock 用户关联查询:**
```sql
-- 查找用户相关的 OpenZeppelin Timelock 合约
SELECT 
    ot.*,
    CASE 
        WHEN ot.creator_address = $1 THEN 'creator'
        WHEN ot.admin = $1 THEN 'admin'
        WHEN $1 = ANY(ot.proposers) THEN 'proposer'
        WHEN $1 = ANY(ot.executors) THEN 'executor'
        ELSE 'related'
    END as user_relation
FROM openzeppelin_timelocks ot
WHERE ot.status = 'active'
  AND (
    ot.creator_address = $1 OR          -- 创建者
    ot.admin = $1 OR                   -- 管理员
    $1 = ANY(ot.proposers) OR          -- 提议者
    $1 = ANY(ot.executors)             -- 执行者
  )
  AND ($2::int IS NULL OR ot.chain_id = $2); -- 可选的链ID过滤
```

### 6.6 链上信息获取流程

#### 6.6.1 合约信息同步流程

1. **接收前端请求** - 获取基本合约信息（用户地址、合约标准、合约地址、链ID、备注）
2. **基本验证** - 验证地址格式、链ID有效性等
3. **链上连接** - 使用RPC管理器获取健康的RPC连接
4. **合约验证** - 验证合约地址是否为有效的Timelock合约
5. **信息获取**:
   - **Compound**: 调用 GRACE_PERIOD()、MINIMUM_DELAY()、MAXIMUM_DELAY()、admin()、pendingAdmin()、delay()
   - **OpenZeppelin**: 调用 getMinDelay()、getRoleMembers() 等方法获取角色信息
6. **数据存储** - 将完整信息存储到对应的表中
7. **返回结果** - 返回同步状态和合约信息

#### 6.6.2 同步策略

- **初始同步**: 合约导入时立即同步
- **定期同步**: 定期更新可能变化的信息（如管理员、角色等）
- **事件驱动**: 监听到相关事件时触发同步
- **失败重试**: 同步失败时记录错误，支持手动重试


## 模块七：用户相关数据查询系统

### 7.1 用户关联合约发现

**关联关系发现逻辑:**
1. **创建者关系**: 通过合约创建交易的 `from` 地址识别
2. **管理员关系**: 通过 `admin`、`pending_admin` 字段识别
3. **角色关系**: 通过 `proposers`、`executors`、`cancellers` 列表识别
4. **参与者关系**: 通过交易记录的 `from_address` 识别活跃参与者

### 7.2 用户交易查询API

**查询接口设计:**
```go
// 获取用户相关的timelock交易
type GetUserTimelockTransactionsRequest struct {
    UserAddress string  `json:"user_address" binding:"required"`
    ChainID     *int    `json:"chain_id,omitempty"`
    Standard    *string `json:"standard,omitempty"`
    Status      *string `json:"status,omitempty"`
    Page        int     `json:"page" binding:"min=1"`
    PageSize    int     `json:"page_size" binding:"min=1,max=100"`
}

type GetUserTimelockTransactionsResponse struct {
    Transactions []UserTimelockTransaction `json:"transactions"`
    Total        int64                     `json:"total"`
    Page         int                       `json:"page"`
    PageSize     int                       `json:"page_size"`
}

type UserTimelockTransaction struct {
    // 基本交易信息
    TxHash          string    `json:"tx_hash"`
    BlockNumber     uint64    `json:"block_number"`
    BlockTimestamp  time.Time `json:"block_timestamp"`
    ChainID         int       `json:"chain_id"`
    ChainName       string    `json:"chain_name"`
    
    // 合约信息
    ContractAddress string    `json:"contract_address"`
    Standard        string    `json:"standard"`
    
    // 用户角色和关系
    UserRole        string    `json:"user_role"`        // creator, admin, proposer, executor, etc.
    UserRelation    string    `json:"user_relation"`    // 用户与该交易的关系
    
    // 交易详情
    EventType       string                 `json:"event_type"`
    FlowID          *string                `json:"flow_id,omitempty"`
    FlowStatus      *string                `json:"flow_status,omitempty"`
    TargetAddress   *string                `json:"target_address,omitempty"`
    FunctionSig     *string                `json:"function_signature,omitempty"`
    Value           *string                `json:"value,omitempty"`
    Description     *string                `json:"description,omitempty"`
    
    // 时间信息
    ProposedAt      *time.Time             `json:"proposed_at,omitempty"`
    ExecutableAt    *time.Time             `json:"executable_at,omitempty"`
    ExecutedAt      *time.Time             `json:"executed_at,omitempty"`
    CancelledAt     *time.Time             `json:"cancelled_at,omitempty"`
}
```

## 模块八：重新扫描功能

### 8.1 重扫机制设计

**重扫触发方式:**
1. **API触发**: 提供重扫接口，管理员可以指定链和起始区块
2. **自动触发**: 检测到数据异常时自动重扫
3. **定时触发**: 定期对关键区块进行重扫验证

**重扫逻辑:**
```go
type RescanRequest struct {
    ChainID         int    `json:"chain_id" binding:"required"`
    FromBlock       uint64 `json:"from_block" binding:"required"`
    ToBlock         *uint64 `json:"to_block,omitempty"`  // 空表示扫到最新
    ForceRescan     bool   `json:"force_rescan"`          // 是否强制重扫已扫描的区块
    CleanupExisting bool   `json:"cleanup_existing"`      // 是否清理现有数据
}

type RescanResponse struct {
    TaskID      string    `json:"task_id"`
    Status      string    `json:"status"`
    StartTime   time.Time `json:"start_time"`
    Progress    *RescanProgress `json:"progress,omitempty"`
}

type RescanProgress struct {
    CurrentBlock    uint64  `json:"current_block"`
    TargetBlock     uint64  `json:"target_block"`
    ProcessedBlocks uint64  `json:"processed_blocks"`
    FoundEvents     uint64  `json:"found_events"`
    ProcessedEvents uint64  `json:"processed_events"`
    ErrorCount      uint64  `json:"error_count"`
    ProgressPercent float64 `json:"progress_percent"`
}
```

### 8.2 重扫策略

1. **增量重扫**: 只处理指定区块范围内的新数据
2. **完全重扫**: 清理现有数据，重新扫描指定区块范围
3. **验证重扫**: 对比现有数据与链上数据，修复不一致

## 模块九：通知系统预留接口

### 9.1 通知系统设计 (预留)

**通知事件定义:**
```go
type NotificationEvent struct {
    EventType       string                 `json:"event_type"`
    UserAddress     string                 `json:"user_address"`
    ChainID         int                    `json:"chain_id"`
    ContractAddress string                 `json:"contract_address"`
    
    // 事件详情
    FlowID          *string                `json:"flow_id,omitempty"`
    TxHash          string                 `json:"tx_hash"`
    BlockNumber     uint64                 `json:"block_number"`
    
    // 通知内容
    Title           string                 `json:"title"`
    Message         string                 `json:"message"`
    Severity        string                 `json:"severity"`  // info, warning, critical
    
    // 时间信息
    OccurredAt      time.Time              `json:"occurred_at"`
    NotificationAt  time.Time              `json:"notification_at"`
}
```

**通知触发条件:**
1. **提案创建**: 用户创建的合约有新提案
2. **状态变更**: 提案状态发生变化 (队列→可执行→已执行)
3. **权限变更**: 用户在合约中的权限发生变化
4. **紧急情况**: 合约进入紧急模式或发生异常

## 开发实施计划

### 第一阶段：基础设施建设 (1-2周) ✅ **已完成**

**1.1 数据库设计和迁移 (3-4天)** ✅ **已完成**
- [x] 设计和创建新的数据库表结构
- [x] 编写数据库迁移脚本 
- [x] 创建必要的索引
- [x] 测试数据库性能

**1.2 配置管理扩展 (1-2天)** ✅ **已完成**
- [x] 扩展 config.yaml 配置项
- [x] 更新配置结构体和验证逻辑
- [x] 添加扫链相关配置项

**1.3 类型定义和基础结构 (2-3天)** ✅ **已完成**
- [x] 定义扫链相关的类型结构
- [x] 创建事件数据结构
- [x] 设计API请求响应结构
- [x] 编写基础的数据转换函数

### 第二阶段：RPC管理和健康检查 (1周) ✅ **已完成**

**2.1 RPC管理器开发 (3-4天)** ✅ **已完成**
- [x] 实现RPC健康检查逻辑
- [x] 开发RPC自动切换机制
- [x] 添加RPC性能监控
- [x] 实现错误重试策略

### 第三阶段：扫链核心引擎 (2-3周) ✅ **已完成**

**3.1 区块扫描器开发 (1周)** ✅ **已完成**
- [x] 实现扫链管理器
- [x] 开发单链扫描器
- [x] 编写区块处理逻辑
- [x] 实现扫描进度管理

**3.2 事件处理器开发 (1周)** ✅ **已完成**
- [x] 实现Compound事件解析器
- [x] 开发OpenZeppelin事件解析器
- [x] 编写事件数据构建器
- [x] 实现批量事件处理

**3.3 扫链引擎集成测试 (3-5天)** ✅ **已完成**
- [x] 集成测试多链扫描
- [x] 测试事件识别准确性
- [x] 验证数据一致性
- [x] 性能优化和调试

### 第四阶段：交易流程关联系统 (1-2周)

**4.1 流程关联逻辑开发 (1周)**
- [ ] 实现Compound流程关联
- [ ] 开发OpenZeppelin流程关联
- [ ] 编写流程状态管理
- [ ] 实现流程数据构建

**4.2 流程系统测试 (3-5天)**
- [ ] 测试流程识别准确性
- [ ] 验证状态转换逻辑
- [ ] 集成测试完整流程
- [ ] 数据一致性验证

### 第五阶段：合约管理系统重构 (1-2周)



### 第六阶段：用户数据查询系统 (1周)

**6.1 用户关联发现 (3-4天)**
- [ ] 实现用户关联合约发现
- [ ] 开发关联关系管理
- [ ] 编写用户权限分析
- [ ] 实现关联数据维护

**6.2 用户查询API (2-3天)**
- [ ] 开发用户交易查询API
- [ ] 实现分页和过滤功能
- [ ] 编写查询优化逻辑
- [ ] 测试查询性能

### 第七阶段：重扫功能和管理工具 (1周)

**7.1 重扫功能开发 (4-5天)**
- [ ] 实现重扫触发机制
- [ ] 开发重扫进度跟踪
- [ ] 编写数据一致性验证
- [ ] 实现重扫任务管理

**7.2 管理工具开发 (2-3天)**
- [ ] 开发扫链状态监控API
- [ ] 实现扫链控制接口 (启动/停止/重启)
- [ ] 编写扫链统计和报告
- [ ] 测试管理功能

### 第八阶段：系统集成和优化 (1-2周)

**8.1 系统集成测试 (1周)**
- [ ] 集成测试完整扫链系统
- [ ] 验证多链并发扫描
- [ ] 测试系统稳定性
- [ ] 验证数据准确性

**8.2 性能优化和部署准备 (3-5天)**
- [ ] 优化数据库查询性能
- [ ] 调整扫链参数配置
- [ ] 编写部署文档
- [ ] 准备监控和报警

### 第九阶段：通知系统预留 (预留阶段)

**9.1 通知系统接口设计 (2-3天)**
- [ ] 设计通知事件结构
- [ ] 定义通知触发条件
- [ ] 预留通知系统接口
- [ ] 编写通知系统集成文档

## 关键技术细节

### 1. 并发控制策略
- 每条链独立协程，避免链间相互影响
- 使用工作池控制并发数量，避免资源耗尽
- 实现优雅关闭机制，确保数据一致性

### 2. 错误处理和容错
- 多级错误重试机制 (RPC级别、事务级别、任务级别)
- 详细的错误日志和监控
- 数据一致性校验和自动修复

### 3. 性能优化策略
- 批量处理区块和事件，减少数据库IO
- 使用Redis缓存热点数据
- 数据库查询优化和索引策略
- 智能扫描速率调整

### 4. 数据安全保证
- 事务性处理确保数据一致性
- 数据校验和完整性检查
- 备份和恢复机制
- 审计日志记录

## 监控和运维

### 1. 关键指标监控
- 扫描进度和延迟监控
- RPC健康状态和响应时间
- 事件处理成功率和错误率
- 数据库性能和存储使用

### 2. 报警机制
- 扫描停滞或异常报警
- RPC不可用报警
- 数据不一致报警
- 系统资源异常报警

### 3. 运维工具
- 扫链状态实时监控界面
- 重扫和数据修复工具
- 性能分析和优化建议
- 配置热更新功能

## 总结

本设计方案提供了一个完整、高效、稳定的扫链系统架构，具备以下特点：

1. **高可靠性**: 多重容错机制和数据一致性保证
2. **高性能**: 并发扫描和智能优化策略
3. **可扩展性**: 模块化设计便于功能扩展
4. **易维护性**: 完善的监控和运维工具
5. **安全性**: 多层次的数据验证和安全保护

该方案充分考虑了项目的现有架构，与当前代码风格和技术栈保持一致，确保能够无缝集成到现有系统中。通过分阶段的实施计划，可以逐步构建一个功能完善的扫链系统。